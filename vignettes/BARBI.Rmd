---
title: "BARBI Workflow"
author:
  name: Pratheepa Jeganathan
  affiliation: Department of Statistics, Stanford University
  email: jpratheepa31@gmail.com
package: BARBI
abstract: >
  BAyesian Reduction in Background Interference (BARBI) provides a reproducible and automated process to remove contaminating bacterial and viral DNA from metagenomic shotgun sequencing data in the setting of ultra low-biomass samples.
output:
  BiocStyle::html_document:
    toc_float: true
vignette: >
    %\VignetteIndexEntry{BARBI Workflow}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
bibliography: BARBI.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Install [R](https://www.r-project.org/) and [RStudio](https://www.rstudio.com/). Open this `Rmd` `r Githubpkg("rstudio/rmarkdown")` file in RStudio. Then run the following code to install all required packages.

```{r install_packages}
pkgs <- c("DESeq2","phyloseq","dplyr",
          "tidyr","R.utils","BiocParallel",
          "doParallel","parallel","HDInterval",
          "grid","xtable","gtable",
          "gridExtra","BiocStyle","magrittr")
source("http://bioconductor.org/biocLite.R")
biocLite(setdiff(pkgs,installed.packages()))

devtools::install_github("PratheepaJ/BARBI",auth_token = "33c5f43cc3f1772c19a441e15fc9478c3bf91b67")
```

Load packages:
```{r load_packages}
library(BARBI)
library(devtools)
library(phyloseq)
library(DESeq2)
library(dplyr)
library(tidyr)
library(R.utils)
library(BiocParallel)
library(doParallel)
library(parallel)
library(HDInterval)
library(grid)
library(xtable)
library(gtable)
library(gridExtra)
library(BiocStyle)
library(magrittr)
```

Set the computational resources
```{r}
ncores = as.integer(Sys.getenv("SLURM_NTASKS"))
if(is.na(ncores)) ncores <- parallel::detectCores()
```


#      Load the example dataset stored as a phyloseq object in the ``BARBI`` package (or use your own data stored as a phyloseq object)

##      Load the phyloseq object

This example dataset is taken from a study that involved metagenomic shotgun sequencing on plasma from patients with suspected sepsis ( @cheng2017integration ).

```{r read-phylo}
ps <- ps
```

Remove library controls samples from the dataset, which will not be needed for this BARBI analysis. 

```{r remove_unwanted_controls}
ps <- subset_samples(ps,Sample_Type=!"Library_Control")
```

In a previous PCoA analysis of this dataset, the samples separated into three separate clusters, which correlated with three groups of DNA extraction batches. 

To reduce the batch-effects of contamination, we specified three "blocks" of samples, and analyzed each block separately with BARBI.  (Pratheepa, consider adding the code for PCoA of these samples). 

We highly recommend that you keep track of batch effects (esp. DNA extraction and library prep batches), visualize your data with PCoA, and separate your data into different blocks of necessary. 

```{r adding_blocks}
set1 <- c("1","2","3","4","11","12")
set2 <- c("5","6","7","8","9","10")
setP <- "P"
ext.num <- sample_data(ps)$Extraction_Number

blocks <-ifelse(ext.num %in% set1, "Set1", ifelse(ext.num %in% set2, "Set2", "SetP"))

sample_data(ps)$block <- blocks
```

Subset samples such that only patient plasma, healthy subject control, and negative controls are included in the final phyloseq object. 

```{r choose_samples}
ps <- subset_samples(ps,Sample_Type %in% c("Healthy_Plasma","Patient_Plasma","Control"))
```

Identify the species that are not present in at least one plasma sample and removed them from the phyloseq object. Label these species as contaminants. 

```{r filter_taxa}
ps <- prune_taxa(taxa_sums(ps)>0, ps)
ps_plasma <- subset_samples(ps,Sample_Type%in%c("Healthy_Plasma","Patient_Plasma"))
prevTaxaP <- apply(otu_table(ps_plasma), 1 ,function(x){sum(x>0)})

Contaminants1 <- names(prevTaxaP)[prevTaxaP==0]
ps <- prune_taxa(prevTaxaP>0,ps)
```

Specify that the samples are on the columns and species are on the rows of `otu_table`. 

Check the distribution of library size/sample depth to see whether there are samples with very small library sizes that should be dropped from the analysis.

```{r filter-samples}
if(dim(otu_table(ps))[1]!=ntaxa(ps)){otu_table(ps) <- t(otu_table(ps))}
totalReads <- colSums(otu_table(ps))
hist(log(totalReads),yaxs="i",xaxs="i",main="Distribution of total reads per sample",breaks=50)
```



See a summary of the plasma and negative control samples in each block. 

```{r summary_stat}
table(sample_data(ps)$Sample_Type,sample_data(ps)$block)
```

#       Bayesian Inference 

##      Prepare the phyloseq object for the Bayesian inference

We use Bayesian inference to identify contaminants in each block separately to account for the batch-effects of contamination. 

Thus, split the phyloseq object into multiple phyloseq objects corresponding to each block, and store the phyloseq objects as a list of phyloseq objects, `psByBlock`. 

Select negative control samples from each block and store as a list of phyloseq objects, `psNCbyBlock`. 

Select all species that have a prevalence of zero (i.e., have zero reads) in all negative control samples for each block and store as a list of phyloseq objects, `psallzeroInNC`.

Select all plasma samples from each block and store as a list of phyloseq objects, `psPlByBlock`.

```{r list_of_phyloseq}
psBlockResult <- psBlockResults(ps, sampleTypeVar = "Sample_Type", caselevels = c("Healthy_Plasma","Patient_Plasma"), controllevel="Control", sampleName = "Sample_ID", blockVar = "block")

psByBlock <- psBlockResult[[1]]
psNCbyBlock <- psBlockResult[[2]]
psallzeroInNC <- psBlockResult[[3]]
psPlByBlock <- psBlockResult[[4]]

saveRDS(psByBlock,"./psByBlock.rds")
```

##      Estimate the distribution parameters for the instensity of contamination in negative control samples

Estimate the gamma distribution parameters for the intensity of contaminants using the negative control samples for each block. 

`add1 == TRUE` corresponds to adding 1 to the otu table and `add1 == FALSE` corresponds to choosing 'poscounts' for the size factor calculation method in `DESeq::estimateSizeFactors`. The latter is the default option.

```{r estimate_Cont_Intensity_ncontrols}
alphaBetaNegControl <- alphaBetaNegControl(psNCbyBlock = psNCbyBlock, add1 = FALSE)
```

##      Estimate the distribution parameters for the intensity of contamination in each plasma sample

For each plasma sample, estimate the gamma distribution parameters for the intensity of contamination using the scaling property of the gamma distribution.

Choosing `stringent == TRUE` specifies BARBI to not using the scaling property for the species with the mean intensity of contamination less than one. (Pratheepa, what does this mean for the user? Shoudl we say something like 'This is one of two parameters that allows for more stringent subtraction of contaminants, especially for those at low abundance.')

```{r estimate_Cont_Intensity_plasma}
num_blks <- length(alphaBetaNegControl)
blks <- seq(1, num_blks) %>% as.list

gammaPrior_all_blks <- lapply(blks, function(x){
        gammaPrior <- alphaBetaContInPlasma(psPlByBlock = psPlByBlock, psallzeroInNC = psallzeroInNC, blk = x, alphaBetaNegControl=alphaBetaNegControl, stringent = FALSE)
        return(gammaPrior)
})
```

##      Sampling from the posterior for the intensity of true signal

For all samples and for all taxa, sample from the posterior for the intensity of true signal using the Metropolis-Hasting MCMC. Specifify the number of iterations in the MCMC using the option `itera`. 

Save the gamma prior for the intensity of contamination and the posterior samples.

The  suggeseted itera is 10,000. 

```{r sampling_post_true_int}
t1 <- proc.time()

post_all_blocks <- lapply(blks,function(x){
        post_int_all_taxa <- samplingPosterior(psPlByBlock = psPlByBlock,
                blk = x,
                gammaPrior_Cont = gammaPrior_all_blks[[x]],
                itera = 500,
                ncores = 4)
        return(post_int_all_taxa)
})

proc.time()-t1


gammaPrior_posTrueSing_all_blocks <- list(gammaPrior_all_blks,post_all_blocks)

saveRDS(gammaPrior_posTrueSing_all_blocks, file= "./gammaPrior_posTrueSing_all_blocks.rds")
```

#       Display the results

##     Make summaires from the BARBI results.

Choose the number of MCMC to be removed using the option `burnIn`.  It must be less than `itera`.

Choose the coverage probability to construct the highest posterior density interval using the option `cov.pro`.

Taxa are labeled as contaminants if the lower limit of the true signal is greater than the upper limit of the contaminant. (Just wondering, are you going to include the signal:noise ratio in this?)

The suggested burnIn is 5000 for itera = 10000.
```{r make_tables}
itera <- 1000
burnIn <- 100
cov.pro <- .95
mak_tab <- TRUE
psByBlock <- readRDS("./psByBlock.rds")

gammaPrior_posTrueSing_all_blocks <- readRDS("./gammaPrior_posTrueSing_all_blocks.rds")

gammaPrior_all_blks <- gammaPrior_posTrueSing_all_blocks[[1]]
post_all_blocks <- gammaPrior_posTrueSing_all_blocks[[2]]

all_real_taxa_lt <- list()

for(blk in 1:num_blks){

                taxa_post_all_sam <- post_all_blocks[[blk]]
                gammPrior <- gammaPrior_all_blks[[blk]]

                total_summary_table <- NULL

                all_real_taxa <- character()

                for(sam in 1:nsamples(psPlByBlock[[blk]])){

                        taxa_post <- taxa_post_all_sam[[sam]]
                        acceptance <- list()
                        exp_post_s <- list()
                        lower.s <- list()
                        upper.s <- list()
                        lower.b <- list()
                        upper.b <- list()
                        all.zero.nc <- list()

                        for(taxa in 1:length(taxa_post)){
                                burnIn  <- burnIn
                                acceptance[[taxa]]  <-  1-mean(duplicated(taxa_post[[taxa]][-(1:burnIn),]))

                                exp_post_s[[taxa]] <- mean(taxa_post[[taxa]][-(1:burnIn),])

                                hdi.v <- hdi(taxa_post[[taxa]][-(1:burnIn),], credMass = cov.pro)
                                lower.s[[taxa]] <- round(hdi.v[1], digits = 0)
                                upper.s[[taxa]] <- round(hdi.v[2], digits = 0)

                                hdi.b <- hdi(rgamma((itera-burnIn+1), shape=gammPrior[[sam]][[1]][taxa], rate = gammPrior[[sam]][[2]][taxa]), credMass = cov.pro)
                                lower.b[[taxa]] <- round(hdi.b[1], digits = 0)
                                upper.b[[taxa]] <- round(hdi.b[2], digits = 0)


                                all.zero.nc[[taxa]] <-  gammPrior[[sam]][[5]][taxa]
                        }


                        df <- data.frame(Species=taxa_names(psPlByBlock[[blk]]),
                                         xj=as.numeric(gammPrior[[sam]][[3]]),
                                         l.s=unlist(lower.s),
                                         u.s=unlist(upper.s),
                                         l.b=unlist(lower.b),
                                         u.b=unlist(upper.b),
                                         all.zero.nc=unlist(all.zero.nc)
                        )

                        df <- arrange(filter(df,(l.s>u.b)&(l.s>0)), desc(xj))


                        if(dim(df)[1]==0){
                                df <- data.frame(Species="Negative",
                                                 xj="Negative",
                                                 l.s="Negative",
                                                 u.s="Negative",
                                                 l.b ="Negative",
                                                 u.b="Negative",
                                                 all.zero.nc = "Negative")
                        }


                        all_real_taxa <- c(all_real_taxa,
                                           as.character(df$Species))
                        if(mak_tab){
                                filname <- paste("./",
                                                 sample_names(psPlByBlock[[blk]])[sam],
                                                 ".png",
                                                 sep="")

                                png(filname, height = 600, width = 750)

                                df.p <- tableGrob(df)
                                title <- textGrob(sample_names(psPlByBlock[[blk]])[sam], gp = gpar(fontsize = 12))

                                padding <- unit(0.5,"line")

                                df.p <- gtable_add_rows(
                                        df.p, heights = grobHeight(title) + padding, pos = 0
                                )

                                df.p <- gtable_add_grob(
                                        df.p, list(title),
                                        t = 1, l = 1, r = ncol(df.p) 
                                )

                                grid.newpage()
                                grid.draw(df.p)
                                dev.off()
                        }


                        all_real_taxa <- unique(all_real_taxa)
                }

                all_real_taxa_lt[[blk]] <- all_real_taxa
        }

```

##      Construct a phyloseq object with the true signal
```{r make_phyloseq}
all_real_taxa_lt <- unlist(all_real_taxa_lt)
all_real_taxa_lt <- all_real_taxa_lt[which(!all_real_taxa_lt=="Negative")]
ps_decon <- prune_taxa(all_real_taxa_lt, ps)
```

# Session Info 

```{r session_info}
sessionInfo()
```
